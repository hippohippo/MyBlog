<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Golang on MoonLightWatch的博客</title>
    <link>http://blog.moonlightwatch.me/categories/golang/</link>
    <description>Recent content in Golang on MoonLightWatch的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 01 Aug 2017 00:00:00 +0000</lastBuildDate>
    <atom:link href="/categories/golang/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Golang Json 反序列化 UTF-8 字符串遇到的错误</title>
      <link>http://blog.moonlightwatch.me/post/golang-json-error/</link>
      <pubDate>Tue, 01 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>http://blog.moonlightwatch.me/post/golang-json-error/</guid>
      <description>过程  从 http POST 数据中读取字节数据 将字节数据传入 json.Unmarshal 函数直接反序列化 遇到错误 invalid character &#39;ï&#39; looking for beginning of value  其中 http POST 数据是正常的Json，使用 fmt.Println 能够正常输出，并没有错误中提到的神奇字符
原因 在UTF-8字符转中，有可能会有一个BOM（字节顺序标记）（参见维基百科）
如果你直接输出 POST 的字节数据，会在头部发现 239 187 191 这三个字节，这个就是UTF-8的字节顺序标记。
但是要注意，这个字节顺序标记并不是必须的，有的 UTF-8 数据就是不带这个 BOM 的
解决 既然字节数据头部会有几个非数据字节，那么去掉就好了。
... body = bytes.TrimPrefix(body, []byte(&amp;quot;\xef\xbb\xbf&amp;quot;)) // Or []byte{239, 187, 191} ...  参见 Stackoverflow 中的问题：Got error &amp;ldquo;invalid character &amp;lsquo;ï&amp;rsquo; looking for beginning of value” from json.Unmarshal
最后 果然还是面向 Stackoverflow 编程</description>
    </item>
    
    <item>
      <title>golang 的时间格式化操作</title>
      <link>http://blog.moonlightwatch.me/post/golang-time-format/</link>
      <pubDate>Sat, 15 Jul 2017 00:00:00 +0000</pubDate>
      
      <guid>http://blog.moonlightwatch.me/post/golang-time-format/</guid>
      <description>怎么做 简而言之 time.Now().Format(&amp;quot;2006-01-02 15:04:05&amp;quot;)  你将会获得如同 yyyy-MM-dd hh-mm-ss 这样的输出。
还可以 在 format.go 的源码中我们可以找到一些预定的格式，源码摘抄如下：
const ( ANSIC = &amp;quot;Mon Jan _2 15:04:05 2006&amp;quot; UnixDate = &amp;quot;Mon Jan _2 15:04:05 MST 2006&amp;quot; RubyDate = &amp;quot;Mon Jan 02 15:04:05 -0700 2006&amp;quot; RFC822 = &amp;quot;02 Jan 06 15:04 MST&amp;quot; RFC822Z = &amp;quot;02 Jan 06 15:04 -0700&amp;quot; // RFC822 with numeric zone RFC850 = &amp;quot;Monday, 02-Jan-06 15:04:05 MST&amp;quot; RFC1123 = &amp;quot;Mon, 02 Jan 2006 15:04:05 MST&amp;quot; RFC1123Z = &amp;quot;Mon, 02 Jan 2006 15:04:05 -0700&amp;quot; // RFC1123 with numeric zone RFC3339 = &amp;quot;2006-01-02T15:04:05Z07:00&amp;quot; RFC3339Nano = &amp;quot;2006-01-02T15:04:05.</description>
    </item>
    
    <item>
      <title>在 golang 中使用 Json</title>
      <link>http://blog.moonlightwatch.me/post/golang-json/</link>
      <pubDate>Wed, 10 May 2017 00:00:00 +0000</pubDate>
      
      <guid>http://blog.moonlightwatch.me/post/golang-json/</guid>
      <description>序列化 序列化对象将使用 encoding/json 中的 Marshal 函数。
函数原型为：func Marshal(v interface{}) ([]byte, error)
以下是官网给出的例子：
package main import ( &amp;quot;encoding/json&amp;quot; &amp;quot;fmt&amp;quot; &amp;quot;os&amp;quot; ) func main() { type ColorGroup struct { ID int Name string Colors []string } group := ColorGroup{ ID: 1, Name: &amp;quot;Reds&amp;quot;, Colors: []string{&amp;quot;Crimson&amp;quot;, &amp;quot;Red&amp;quot;, &amp;quot;Ruby&amp;quot;, &amp;quot;Maroon&amp;quot;}, } b, err := json.Marshal(group) if err != nil { fmt.Println(&amp;quot;error:&amp;quot;, err) } os.Stdout.Write(b) }  需要注意的是：json.Marshal返回了[]byte类型，通常情况下，需要将其转换为string类型使用。
反序列化 反序列化对象将使用 encoding/json 中的 Unmarshal 函数。</description>
    </item>
    
  </channel>
</rss>
